<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Suica Pool Simulator</title>

  <script src="suica.js"></script>
  <style>
    body { margin: 0; }
  </style>
</head>

<body>
  <suica fullWindow id="S" ontime="tick">
    <orbit id="O"></orbit>
  </suica>

  <script>
    // ---------------------------
    // 1) Pool Params
    // ---------------------------
    let L = 60;
    let W = 35;
    let H = 25;
    const wallT = 1.2;

    // ---------------------------
    // 2) Filling Params
    // ---------------------------
    let V = 0;
    let running = true;

    let theta = 0;
    const THETA_MIN = 0;
    const THETA_MAX = 90;

    const Qmax = 20000;
    let Q = 0;

    // Drag state
    let draggingValve = false;
    let dragStartClientX = 0;
    let thetaAtDragStart = 0;
    let activePointerId = null;

    // --- Drain valve ---
    let dtheta = 0;
    const DTHETA_MIN = 0;
    const DTHETA_MAX = 90;
    const QoutMax = 20000;
    let Qout = 0;

    let draggingDrain = false;
    let dDragStartClientX = 0;
    let dthetaAtDragStart = 0;
    let dActivePointerId = null;

    // --- Resize handles ---
    let handleX, handleZ, handleY;
    let draggingHandle = null;
    let handleStartX = 0;
    let handleStartY = 0;
    let startL = 0, startW = 0, startH = 0;

    // Objs
    let faucetBody, faucetNeck, faucetSpout, stream;
    let valveBar1, valveBar2, valveHub, valveHitBox;

    let drainBody, drainSpout, drainStream;
    let drainHub, drainBar1, drainBar2, drainHitBox;

    let floorObj, wallX1, wallX2, wallZ1, wallZ2, waterObj;

    let streamTopY = 0;
    let streamX = 0, streamZ = 0;

    let lastMs = performance.now();

    function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }

    // ---------------------------
    // Pool
    // ---------------------------
    function buildPool() {
      if (floorObj) {
        floorObj.visible = false;
        wallX1.visible = false; wallX2.visible = false;
        wallZ1.visible = false; wallZ2.visible = false;
        waterObj.visible = false;
      }

      floorObj = S.cube([0, wallT/2, 0], [L, wallT, W], 'gainsboro');

      wallZ1 = S.cube([0, H/2,  (W/2 - wallT/2)], [L, H, wallT], 'lightgray');
      wallZ2 = S.cube([0, H/2, -(W/2 - wallT/2)], [L, H, wallT], 'lightgray');

      wallX1 = S.cube([ (L/2 - wallT/2), H/2, 0], [wallT, H, W], 'lightgray');
      wallX2 = S.cube([-(L/2 - wallT/2), H/2, 0], [wallT, H, W], 'lightgray');

      waterObj = S.cube([0, wallT + 0.05, 0], [L - 2*wallT, 0.1, W - 2*wallT], 'deepskyblue');
    }

    function updateWaterFromVolume() {
      const A = (L - 2*wallT) * (W - 2*wallT);
      const Vmax = A * (H - wallT);

      if (!Number.isFinite(V)) V = 0;

      V = clamp(V, 0, Vmax);

      const h = V / A;
      if (V <= 0.0001) {
        waterObj.visible = false;
        return;
      }

      waterObj.visible = true;

      const waterH = h;
      waterObj.size = [L - 2*wallT, waterH, W - 2*wallT];
      waterObj.center = [0, wallT + waterH/2, 0];
    }

    function buildHandles() {
      if (handleX) {
        handleX.visible = false;
        handleY.visible = false;
        handleZ.visible = false;
      }

      handleX = S.cube([L/2 + 3, H/2, 0], [2, 2, 2], 'red');
      handleZ = S.cube([0, H/2, W/2 + 3], [2, 2, 2], 'blue');
      handleY = S.cube([0, H + 3, 0], [2, 2, 2], 'green');

      handleX.alpha = handleY.alpha = handleZ.alpha = 0.8;

      handleX.addEventListener('pointerDown', e => onHandleDown('x', e));
      handleZ.addEventListener('pointerDown', e => onHandleDown('z', e));
      handleY.addEventListener('pointerDown', e => onHandleDown('y', e));
    }

    // ---------------------------
    //Faucet
    // ---------------------------
    function buildFaucet() {
      const fx = L/2 + 12;
      const fy = H + 6;
      const fz = 0;

      const bodyCenterY = fy - 30;
      const bodyH = 45;

      faucetBody = S.cylinder([fx, bodyCenterY, fz], [6, bodyH, 6], 'silver');

      faucetNeck = S.cylinder([fx, fy+6, fz], [5, 12, 5], 'silver');
      faucetNeck.spinS = 90;

      faucetSpout = S.cylinder([fx-8, fy+6, fz], [3.2, 10, 3.2], 'silver');
      faucetSpout.spinS = 90;

      stream = S.cylinder([fx-18, fy-23, fz], [1.2, 30, 1.2], 'deepskyblue');
      stream.visible = false;

      streamX = fx - 18;
      streamZ = fz;
      streamTopY = (fy + 6) - 1.0;

      const vx = fx;
      const vy = bodyCenterY + bodyH + 1;
      const vz = fz;

      valveHub  = S.cylinder([vx, vy, vz], [3.2, 2.2, 3.2], 'dimgray');
      valveBar1 = S.cube([vx, vy, vz], [12, 1.4, 2.2], 'dimgray');
      valveBar2 = S.cube([vx, vy, vz], [2.2, 1.4, 12], 'dimgray');

      valveHitBox = S.cube([vx, vy, vz], [16, 8, 16], 'white');
      valveHitBox.visible = false;

      updateValveVisual();
      updateFlowFromValve();

      valveHub.addEventListener('pointerDown', onValveDown);
      valveBar1.addEventListener('pointerDown', onValveDown);
      valveBar2.addEventListener('pointerDown', onValveDown);
      valveHitBox.addEventListener('pointerDown', onValveDown);
    }

    function updateValveVisual() {
      const wheelSpin = theta * 4;
      valveHub.spinT  = wheelSpin;
      valveBar1.spinT = wheelSpin;
      valveBar2.spinT = wheelSpin;
      valveHitBox.spinT = wheelSpin;
    }

    function updateFlowFromValve() {
      const x = (theta - THETA_MIN) / (THETA_MAX - THETA_MIN);
      Q = Qmax * x * x;
      stream.visible = (Q > 0.5);
    }

    function rebuildFaucetPosition() {
      const fx = L/2 + 12;
      const fy = H + 6;

      const bodyCenterY = fy - 30;
      const bodyH = 45;

      faucetBody.center = [fx, bodyCenterY, 0];
      faucetBody.size = [6, bodyH, 6];

      faucetNeck.center = [fx, fy+6, 0];
      faucetSpout.center = [fx-8, fy+6, 0];

      stream.center = [fx-18, fy-23, 0];

      streamX = fx - 18;
      streamZ = 0;
      streamTopY = (fy + 6) - 1.0;

      const vy = bodyCenterY + bodyH + 1;

      valveHub.center = [fx, vy-1, 0];
      valveBar1.center = [fx, vy, 0];
      valveBar2.center = [fx, vy, 0];
      valveHitBox.center = [fx, vy, 0];
    }

    // ---------------------------
    // Drain valve
    // ---------------------------
    function buildDrain() {
      const dx = -L/2 - 4;
      const dy = wallT + 1;
      const dz = 0;

      drainBody = S.cylinder([dx, dy, dz], [4, 8, 4], 'silver');

      drainSpout = S.cylinder([dx + 7, dy, dz], [3, 14, 3], 'silver');
      drainSpout.spinS = 90;

      drainStream = S.cylinder([dx - 7, dy - 16, dz], [1.0, 16, 1.0], 'deepskyblue');
      drainStream.visible = false;

      const vx = dx;
      const vy = dy + 7.5;
      const vz = dz;

      drainHub  = S.cylinder([vx, vy, vz], [2.8, 2.0, 2.8], 'dimgray');
      drainBar1 = S.cube([vx, vy, vz], [10, 1.2, 2.0], 'dimgray');
      drainBar2 = S.cube([vx, vy, vz], [2.0, 1.2, 10], 'dimgray');

      drainHitBox = S.cube([vx, vy, vz], [14, 8, 14], 'white');
      drainHitBox.visible = false;

      updateDrainVisual();
      updateFlowFromDrain();

      drainHub.addEventListener('pointerDown', onDrainDown);
      drainBar1.addEventListener('pointerDown', onDrainDown);
      drainBar2.addEventListener('pointerDown', onDrainDown);
      drainHitBox.addEventListener('pointerDown', onDrainDown);
    }

    function updateDrainVisual() {
      const wheelSpin = dtheta * 4;
      drainHub.spinT  = wheelSpin;
      drainBar1.spinT = wheelSpin;
      drainBar2.spinT = wheelSpin;
      drainHitBox.spinT = wheelSpin;
    }

    function updateFlowFromDrain() {
      const x = (dtheta - DTHETA_MIN) / (DTHETA_MAX - DTHETA_MIN);
      Qout = QoutMax * x * x;
    }

    function rebuildDrainPosition() {
      const dx = -L/2 - 4;
      const dy = wallT + 1;
      const dz = 0;

      drainBody.center = [dx, dy, dz];
      drainSpout.center = [dx + 7, dy, dz];
      drainStream.center = [dx - 7, dy - 16, dz];

      const vx = dx;
      const vy = dy + 7.5;
      const vz = dz;

      drainHub.center = [vx, vy, vz];
      drainBar1.center = [vx, vy, vz];
      drainBar2.center = [vx, vy, vz];
      drainHitBox.center = [vx, vy, vz];
    }

    // ---------------------------
    // Orbit
    // ---------------------------
    function configureOrbit() {
      O.enablePan = false;

      if (window.THREE && THREE.MOUSE && O.mouseButtons) {
        O.mouseButtons.LEFT  = THREE.MOUSE.PAN;
        O.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;
      }
    }

    // ---------------------------
    // Drag
    // ---------------------------
    function onValveDown(event) {
      event.preventDefault?.();
      event.stopImmediatePropagation?.();
      event.stopPropagation?.();

      draggingValve = true;
      activePointerId = (event.pointerId !== undefined) ? event.pointerId : null;

      dragStartClientX = event.clientX;
      thetaAtDragStart = theta;

      window.addEventListener('pointermove', onPointerMoveValve, { passive: false });
      window.addEventListener('pointerup', onPointerUpValve, { passive: false, once: true });
      window.addEventListener('pointercancel', onPointerUpValve, { passive: false, once: true });
    }

    function onPointerMoveValve(event) {
      if (!draggingValve) return;
      if (activePointerId !== null && event.pointerId !== activePointerId) return;

      event.preventDefault?.();

      const dx = event.clientX - dragStartClientX;
      theta = clamp(thetaAtDragStart + dx * 0.25, THETA_MIN, THETA_MAX);

      updateValveVisual();
      updateFlowFromValve();
    }

    function onPointerUpValve(event) {
      if (activePointerId !== null && event.pointerId !== activePointerId) return;

      draggingValve = false;
      activePointerId = null;

      window.removeEventListener('pointermove', onPointerMoveValve);
    }

    function onDrainDown(event) {
      event.preventDefault?.();
      event.stopImmediatePropagation?.();
      event.stopPropagation?.();

      draggingDrain = true;
      dActivePointerId = (event.pointerId !== undefined) ? event.pointerId : null;

      dDragStartClientX = event.clientX;
      dthetaAtDragStart = dtheta;

      window.addEventListener('pointermove', onPointerMoveDrain, { passive: false });
      window.addEventListener('pointerup', onPointerUpDrain, { passive: false, once: true });
      window.addEventListener('pointercancel', onPointerUpDrain, { passive: false, once: true });
    }

    function onPointerMoveDrain(event) {
      if (!draggingDrain) return;
      if (dActivePointerId !== null && event.pointerId !== dActivePointerId) return;

      event.preventDefault?.();

      const dx = event.clientX - dDragStartClientX;
      dtheta = clamp(dthetaAtDragStart + dx * 0.25, DTHETA_MIN, DTHETA_MAX);

      updateDrainVisual();
      updateFlowFromDrain();
    }

    function onPointerUpDrain(event) {
      if (dActivePointerId !== null && event.pointerId !== dActivePointerId) return;

      draggingDrain = false;
      dActivePointerId = null;

      window.removeEventListener('pointermove', onPointerMoveDrain);
    }

    function onHandleDown(axis, event) {
      event.preventDefault?.();
      event.stopImmediatePropagation?.();
      event.stopPropagation?.();

      draggingHandle = axis;
      handleStartX = event.clientX;
      handleStartY = event.clientY;

      startL = L;
      startW = W;
      startH = H;

      window.addEventListener('pointermove', onHandleMove, { passive: false });
      window.addEventListener('pointerup', onHandleUp, { passive: false, once: true });
      window.addEventListener('pointercancel', onHandleUp, { passive: false, once: true });
    }

    function onHandleMove(event) {
      if (!draggingHandle) return;
      event.preventDefault?.();

      const dx = event.clientX - handleStartX;
      const dy = handleStartY - event.clientY;

      if (draggingHandle === 'x') L = Math.max(10, startL + dx * 0.15);
      if (draggingHandle === 'z') W = Math.max(10, startW + dx * 0.15);
      if (draggingHandle === 'y') H = Math.max(5,  startH + dy * 0.15);

      buildPool();
      updateWaterFromVolume();

      buildHandles();
      rebuildFaucetPosition();
      rebuildDrainPosition();

      const A = (L - 2*wallT) * (W - 2*wallT);
      const Vmax = A * (H - wallT);
      V = clamp(V, 0, Vmax);
      updateWaterFromVolume();
    }

    function onHandleUp(event) {
      draggingHandle = null;
      window.removeEventListener('pointermove', onHandleMove);
    }

    // ---------------------------
    //(onTime)
    // ---------------------------
    function tick() {
      if (!running) return;

      const nowMs = performance.now();
      let dt = (nowMs - lastMs) / 1000;
      lastMs = nowMs;

      dt = clamp(dt, 0, 0.1);

      const A = (L - 2*wallT) * (W - 2*wallT);
      const Vmax = A * (H - wallT);

      const canDrain = (V > 0.0001);
      const effectiveQout = canDrain ? Qout : 0;

      V += (Q - effectiveQout) * dt;
      V = clamp(V, 0, Vmax);

      drainStream.visible = (effectiveQout > 0.5);

      updateWaterFromVolume();

      if (drainStream.visible) {
        const open = (dtheta - DTHETA_MIN) / (DTHETA_MAX - DTHETA_MIN);
        const pulse = 1 + 0.12 * Math.sin((nowMs / 1000) * 18);
        const r = 0.6 + 1.0 * open;
        drainStream.size = [r * pulse, 16, r];
      }

      if (stream.visible) {
        const timeS = nowMs / 1000;

        const open = (theta - THETA_MIN) / (THETA_MAX - THETA_MIN);
        const pulse = 1 + 0.12 * Math.sin(timeS * 18);
        const r = 0.6 + 1.0 * open;

        let waterSurfaceY = (V > 0.0001) ? (waterObj.center[1] + waterObj.size[1] / 2) : wallT;
        waterSurfaceY = Math.min(waterSurfaceY, streamTopY - 0.2);

        let len = streamTopY - waterSurfaceY;
        len = clamp(len, 0.2, 200);

        stream.size = [r * pulse, len, r];
        stream.center = [streamX, waterSurfaceY, streamZ];
      }

    }

    // ---------------------------
    // Start
    // ---------------------------
    buildPool();
    updateWaterFromVolume();
    buildFaucet();
    buildDrain();
    buildHandles();
    configureOrbit();
  </script>
</body>
</html>
