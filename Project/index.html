<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Suica Pool Simulator</title>
  <link rel="stylesheet" type="text/css" href="style.css">
  <script src="suica.js"></script>
</head>

<body>
  <div class="content">
  <h1>Басейн с вода</h1>
  <h4>Интерактивен урок |Емил Нешков | 2025</h4>

  <h2>I. Теория</h2>

  <p>
    В този урок ще изследваме задачи от типа <em>пълнене</em> и <em>източване</em> на басейн.
    Такива задачи са класически пример за прилагане на формули за обем, дебит и скорост
    на изменение на величини във времето.
  </p>

  <p>
    Басейнът в нашия модел има формата на правоъгълен паралелепипед с размери:
    <em>L</em> – дължина, <em>W</em> – ширина и <em>H</em> – максимална височина.
    Количеството вода вътре се описва чрез обем <em>V</em>, измерван в литри или кубични метри.
  </p>

  <p>
    Когато през горния кран постъпва вода с дебит <em>Q</em> (литра за секунда),
    обемът на водата в басейна нараства равномерно. Ако в началния момент
    <em>t = 0</em> имаме обем <em>V(0)</em>, то след време <em>t</em> обемът е:
  </p>

  <p formula><em>V(t) = V(0) + Q · t</em></p>

  <p>
    Това означава, че при постоянен дебит водата се увеличава линейно във времето.
    Ако към системата е включен и долен клапан за източване с дебит
    <em>Q<sub>out</sub></em>, тогава реалната промяна на обема е разликата
    между входящия и изходящия поток.
  </p>

  <p formula><em>V(t) = V(0) + (Q − Q<sub>out</sub>) · t</em></p>

  <p>
    Тъй като дъното на басейна е правоъгълник с площ <em>A = L · W</em>,
    височината на водния стълб <em>h</em> е свързана с обема чрез:
  </p>

  <p formula><em>h = V / (L · W)</em></p>

  <p>
    Това показва важна зависимост: при еднакъв дебит, басейн с по-голяма площ на дъното
    се пълни по-бавно (нивото расте по-бавно), а по-малък басейн – по-бързо.
  </p>

  <h2>II. Какво показва симулаторът</h2>

  <p>
    В интерактивното поле по-долу можете да променяте:
    размера на басейна, отварянето на горния кран (дебит <em>Q</em>)
    и долния клапан за източване (<em>Q<sub>out</sub></em>).
    Всички величини се изчисляват в реално време и се показват в панела вдясно.
  </p>

  <p>
    Показателите включват текущия обем вода, височината на водата, процента запълване
    и двата дебита. Така можете да проверявате формулите от теорията с експеримент.
  </p>

  <h2>III. Задачи</h2>

  <h3>Задача №1</h3>
  <p>
    Настройте басейна на избрани от вас размери. Отворете крана така, че
    водата да започне да тече. Измерете за колко време нивото достига
    <em>50%</em> и <em>90%</em> от максималната височина.
  </p>

  <h3>Задача №2</h3>
  <p>
    Оставете дебита постоянен и променяйте размерите <em>L</em> и <em>W</em>.
    Наблюдавайте как се променя скоростта на покачване на нивото <em>h</em>.
    Направете извод за влиянието на площта на дъното.
  </p>

  <h3>Задача №3</h3>
  <p>
    Задайте максимален дебит <em>Q<sub>max</sub></em> от контролите.
    Намерете такава стойност на <em>Q</em>, че басейнът да се напълни
    напълно за точно <em>1 минута</em> при дадени размери.
  </p>

  <h3>Задача №4</h3>
  <p>
    Напълнете басейна до половината и след това отворете долния клапан.
    Опитайте се да балансирате двата дебита така, че нивото на водата
    да остане приблизително постоянно.
  </p>

  <h2>IV. Интерактивно поле</h2>
</div>


<div class="sim-layout">

  <div class="panel">
    <div class="box">
      <h3>Контроли</h3>

      <div class="control">
        <label>Максимален дебит <span class="unit">Qmax (L/s)</span></label>
        <input id="qmax" type="range" min="0" max="30000" step="100" value="20000">
        <div class="value"><span id="qmaxValue">20000</span> L/s</div>
      </div>

      <div class="buttons">
        <button id="btnRun">▶ Старт</button>
        <button id="btnPause">⏸ Пауза</button>
        <button id="btnReset">⟲ Нулирай</button>
      </div>
    </div>
  </div>

  <suica width="600" height="420" id="S" ontime="tick">
    <orbit id="O"></orbit>
  </suica>

  <div class="panel">
    <div class="box">
      <h3>Показатели</h3>

      <div class="stats">
        <div class="stat"><div class="name">Размери</div><div class="value" id="dims">–</div></div>
        <div class="stat"><div class="name">Обем</div><div class="value" id="vol">– L</div></div>
        <div class="stat"><div class="name">Ниво</div><div class="value" id="level">– cm</div></div>
        <div class="stat"><div class="name">Запълване</div><div class="value" id="fill">– %</div></div>
        <div class="stat"><div class="name">Q вход</div><div class="value" id="qin">– L/s</div></div>
        <div class="stat"><div class="name">Q изход</div><div class="value" id="qout">– L/s</div></div>
      </div>

      <p class="hint">
        По-голямо дъно ⇒ по-бавно покачване на нивото при същия дебит.
      </p>
    </div>
  </div>
</div>

<div class="solutions">
  <h2>V. Решения</h2>
  <p>
    Тази секция съдържа примерни решения и насоки. Попълвайте числата според избраните от вас размери и дебити.
  </p>

  <details open>
    <summary><strong>Решение — Задача №1</strong></summary>
    <p>
      Цел: време до 50% и 90% от максималната височина.
      Първо намираме целевите височини:
      <em>h<sub>50</sub> = 0.5H</em>, <em>h<sub>90</sub> = 0.9H</em>.
    </p>
    <p>
      Обемът при дадена височина е <em>V = L·W·h</em>.
      Ако басейнът започва от <em>V(0)</em> и има само пълнене с дебит <em>Q</em>, тогава:
    </p>
    <p class="formula"><em>t = (V<sub>цел</sub> − V(0)) / Q</em></p>
    <p>
      Където <em>V<sub>цел</sub> = L·W·h<sub>цел</sub></em>.
      За 50% и 90% заместваш съответно <em>h<sub>цел</sub></em>.
    </p>
  </details>

  <details>
    <summary><strong>Решение — Задача №2</strong></summary>
    <p>
      Височината се променя със скорост:
    </p>
    <p class="formula"><em>dh/dt = (Q − Q<sub>out</sub>) / (L·W)</em></p>
    <p>
      Извод: при еднакъв нетен дебит <em>(Q − Q<sub>out</sub>)</em>, по-голяма площ <em>L·W</em>
      означава по-бавно покачване на нивото, а по-малка площ — по-бързо.
    </p>
  </details>

  <details>
    <summary><strong>Решение — Задача №3</strong></summary>
    <p>
      Търсим дебит <em>Q</em>, така че басейнът да се напълни за <em>t = 60s</em>.
      При празен басейн: <em>V(0)=0</em>, целевият обем е <em>V = L·W·H</em>.
    </p>
    <p class="formula"><em>Q = (L·W·H) / 60</em></p>
    <p>
      Ако работиш в литри, увери се, че мерните единици са еднакви (m³ ↔ L).
      <em>1 m³ = 1000 L</em>.
    </p>
  </details>

  <details>
    <summary><strong>Решение — Задача №4</strong></summary>
    <p>
      За да остане нивото приблизително постоянно, нетният дебит трябва да е близо до 0:
    </p>
    <p class="formula"><em>Q ≈ Q<sub>out</sub></em></p>
    <p>
      Практически: напълни до 50%, после плавно увеличавай <em>Q<sub>out</sub></em> докато
      индикаторът за ниво спре да се променя значимо. Малки разлики водят до бавно покачване/спад.
    </p>
  </details>
</div>


  <hr>
  <h4>2025</h4>
  
  <script>
    //--- Pool Params ---
    let L = 60;
    let W = 35;
    let H = 25;
    const wallT = 1.2;

    //--- Filling Params ---
    let V = 0;
    let running = true;

    let theta = 0;
    const THETA_MIN = 0;
    const THETA_MAX = 90;

    let Qmax = 20000;
    let Q = 0;

    //--- Drag state ---
    let draggingValve = false;
    let dragStartClientX = 0;
    let thetaAtDragStart = 0;
    let activePointerId = null;

    // --- Drain valve ---
    let dtheta = 0;
    const DTHETA_MIN = 0;
    const DTHETA_MAX = 90;
    const QoutMax = 20000;
    let Qout = 0;

    let draggingDrain = false;
    let dDragStartClientX = 0;
    let dthetaAtDragStart = 0;
    let dActivePointerId = null;

    // --- Resize handles ---
    let handleX, handleZ, handleY;
    let draggingHandle = null;
    let handleStartX = 0;
    let handleStartY = 0;
    let startL = 0, startW = 0, startH = 0;

    // --- Objs ----
    let faucetBody, faucetNeck, faucetSpout, stream;
    let valveBar1, valveBar2, valveHub, valveHitBox;

    let drainBody, drainSpout, drainStream;
    let drainHub, drainBar1, drainBar2, drainHitBox;

    let floorObj, wallX1, wallX2, wallZ1, wallZ2, waterObj;

    let streamTopY = 0;
    let streamX = 0, streamZ = 0;

    let lastMs = performance.now();

    // ---------------------------
    // UI 
    // ---------------------------
    const UI = {
      qmax: null, qmaxValue: null,
      btnRun: null, btnPause: null, btnReset: null,
      dims: null, vol: null, level: null, fill: null, qin: null, qout: null,
      lastUpdateMs: 0
    };

    // ---------------------------
    // Scene ready flag 
    // ---------------------------
    let sceneReady = false;

    function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }

    function fmt(n, d = 2) {
      if (!Number.isFinite(n)) return '–';
      return n.toFixed(d);
    }

    function connectUI() {
      UI.qmax = document.getElementById('qmax');
      UI.qmaxValue = document.getElementById('qmaxValue');

      UI.btnRun = document.getElementById('btnRun');
      UI.btnPause = document.getElementById('btnPause');
      UI.btnReset = document.getElementById('btnReset');

      UI.dims = document.getElementById('dims');
      UI.vol = document.getElementById('vol');
      UI.level = document.getElementById('level');
      UI.fill = document.getElementById('fill');
      UI.qin = document.getElementById('qin');
      UI.qout = document.getElementById('qout');

      if (UI.qmax) {
        Qmax = Number(UI.qmax.value) || Qmax;
        if (UI.qmaxValue) UI.qmaxValue.textContent = String(Qmax);

        UI.qmax.addEventListener('input', () => {
          Qmax = Number(UI.qmax.value) || 0;
          if (UI.qmaxValue) UI.qmaxValue.textContent = String(Qmax);
          updateFlowFromValve();
          updateStats(true);
        });
      }

      UI.btnRun?.addEventListener('click', () => { running = true; });
      UI.btnPause?.addEventListener('click', () => { running = false; updateStats(true); });
      UI.btnReset?.addEventListener('click', () => { V = 0; updateWaterFromVolume(); updateStats(true); });
    }

    function updateStats(force = false) {
      const now = performance.now();
      if (!force && now - UI.lastUpdateMs < 100) return;
      UI.lastUpdateMs = now;

      const A = (L - 2*wallT) * (W - 2*wallT);
      const Vmax = A * (H - wallT);
      const h = (A > 0) ? (V / A) : 0;
      const fillPct = (Vmax > 0) ? (100 * V / Vmax) : 0;

    if (UI.dims) UI.dims.textContent = `L = ${fmt(L,1)} m, W = ${fmt(W,1)} m, H = ${fmt(H,1)} m`;

    if (UI.vol) UI.vol.textContent = `${fmt(V,1)} L / ${fmt(Vmax,1)} L`;

    if (UI.level) UI.level.textContent = `${fmt(h * 100,2)} cm`;

    if (UI.fill) UI.fill.textContent = `${fmt(clamp(fillPct,0,100),1)} %`;

    if (UI.qin) uiSafeSet(UI.qin, `${fmt(Q,1)} L/s (макс. ${fmt(Qmax,0)} L/s)`);

    if (UI.qout) uiSafeSet(UI.qout, `${fmt(Qout,1)} L/s`);

    }

    function uiSafeSet(el, text) {
      if (el) el.textContent = text;
    }

    // ---------------------------
    // Pool
    // ---------------------------
    function buildPool() {
      if (floorObj) {
        floorObj.visible = false;
        wallX1.visible = false; wallX2.visible = false;
        wallZ1.visible = false; wallZ2.visible = false;
        waterObj.visible = false;
      }

      floorObj = S.cube([0, wallT/2, 0], [L, wallT, W], 'gainsboro');

      wallZ1 = S.cube([0, H/2,  (W/2 - wallT/2)], [L, H, wallT], 'lightgray');
      wallZ2 = S.cube([0, H/2, -(W/2 - wallT/2)], [L, H, wallT], 'lightgray');

      wallX1 = S.cube([ (L/2 - wallT/2), H/2, 0], [wallT, H, W], 'lightgray');
      wallX2 = S.cube([-(L/2 - wallT/2), H/2, 0], [wallT, H, W], 'lightgray');

      waterObj = S.cube([0, wallT + 0.05, 0], [L - 2*wallT, 0.1, W - 2*wallT], 'deepskyblue');
    }

    function updateWaterFromVolume() {
      const A = (L - 2*wallT) * (W - 2*wallT);
      const Vmax = A * (H - wallT);

      if (!Number.isFinite(V)) V = 0;

      V = clamp(V, 0, Vmax);

      const h = V / A;
      if (V <= 0.0001) {
        if (waterObj) waterObj.visible = false;
        return;
      }

      if (waterObj) waterObj.visible = true;

      const waterH = h;
      if (waterObj) {
        waterObj.size = [L - 2*wallT, waterH, W - 2*wallT];
        waterObj.center = [0, wallT + waterH/2, 0];
      }
    }

    function buildHandles() {
      if (handleX) {
        handleX.visible = false;
        handleY.visible = false;
        handleZ.visible = false;
      }

      handleX = S.cube([L/2 + 3, H/2, 0], [2, 2, 2], 'red');
      handleZ = S.cube([0, H/2, W/2 + 3], [2, 2, 2], 'blue');
      handleY = S.cube([0, H + 3, 0], [2, 2, 2], 'green');

      handleX.alpha = handleY.alpha = handleZ.alpha = 0.8;

      handleX.addEventListener('pointerDown', e => onHandleDown('x', e));
      handleZ.addEventListener('pointerDown', e => onHandleDown('z', e));
      handleY.addEventListener('pointerDown', e => onHandleDown('y', e));
    }

    // ---------------------------
    //Faucet
    // ---------------------------
    function buildFaucet() {
      const fx = L/2 + 12;
      const fy = H + 6;
      const fz = 0;

      const bodyCenterY = fy - 30;
      const bodyH = 45;

      faucetBody = S.cylinder([fx, bodyCenterY, fz], [6, bodyH, 6], 'silver');

      faucetNeck = S.cylinder([fx, fy+6, fz], [5, 12, 5], 'silver');
      faucetNeck.spinS = 90;

      faucetSpout = S.cylinder([fx-8, fy+6, fz], [3.2, 10, 3.2], 'silver');
      faucetSpout.spinS = 90;

      stream = S.cylinder([fx-18, fy-23, fz], [1.2, 30, 1.2], 'deepskyblue');
      stream.visible = false;

      streamX = fx - 18;
      streamZ = fz;
      streamTopY = (fy + 6) - 1.0;

      const vx = fx;
      const vy = bodyCenterY + bodyH + 0.7;
      const vz = fz;

      valveHub  = S.cylinder([vx, vy, vz], [3.2, 2.2, 3.2], 'dimgray');
      valveBar1 = S.cube([vx, vy, vz], [12, 1.4, 2.2], 'dimgray');
      valveBar2 = S.cube([vx, vy, vz], [2.2, 1.4, 12], 'dimgray');

      valveHitBox = S.cube([vx, vy, vz], [16, 8, 16], 'white');
      valveHitBox.visible = false;

      updateValveVisual();
      updateFlowFromValve();

      valveHub.addEventListener('pointerDown', onValveDown);
      valveBar1.addEventListener('pointerDown', onValveDown);
      valveBar2.addEventListener('pointerDown', onValveDown);
      valveHitBox.addEventListener('pointerDown', onValveDown);
    }

    function updateValveVisual() {
      const wheelSpin = theta * 4;
      valveHub.spinT  = wheelSpin;
      valveBar1.spinT = wheelSpin;
      valveBar2.spinT = wheelSpin;
      valveHitBox.spinT = wheelSpin;
    }

    function updateFlowFromValve() {
      const x = (theta - THETA_MIN) / (THETA_MAX - THETA_MIN);
      Q = Qmax * x * x;
      if (stream) stream.visible = (Q > 0.5);
    }

    function rebuildFaucetPosition() {
      const fx = L/2 + 12;
      const fy = H + 6;

      const bodyCenterY = fy - 30;
      const bodyH = 45;

      faucetBody.center = [fx, bodyCenterY, 0];
      faucetBody.size = [6, bodyH, 6];

      faucetNeck.center = [fx, fy+6, 0];
      faucetSpout.center = [fx-8, fy+6, 0];

      if (stream) stream.center = [fx-18, fy-23, 0];

      streamX = fx - 18;
      streamZ = 0;
      streamTopY = (fy + 6) - 1.0;

      const vy = bodyCenterY + bodyH + 0.7;

      valveHub.center = [fx, vy, 0];
      valveBar1.center = [fx, vy, 0];
      valveBar2.center = [fx, vy, 0];
      valveHitBox.center = [fx, vy, 0];
    }

    // ---------------------------
    // Drain valve
    // ---------------------------
    function buildDrain() {
      const dx = -L/2 - 4;
      const dy = wallT + 1;
      const dz = 0;

      drainBody = S.cylinder([dx, dy, dz], [4, 8, 4], 'silver');

      drainSpout = S.cylinder([dx + 7, dy, dz], [3, 14, 3], 'silver');
      drainSpout.spinS = 90;

      drainStream = S.cylinder([dx - 7, dy - 16, dz], [1.0, 16, 1.0], 'deepskyblue');
      drainStream.visible = false;

      const vx = dx;
      const vy = dy + 7.5;
      const vz = dz;

      drainHub  = S.cylinder([vx, vy, vz], [2.8, 2.0, 2.8], 'dimgray');
      drainBar1 = S.cube([vx, vy, vz], [10, 1.2, 2.0], 'dimgray');
      drainBar2 = S.cube([vx, vy, vz], [2.0, 1.2, 10], 'dimgray');

      drainHitBox = S.cube([vx, vy, vz], [14, 8, 14], 'white');
      drainHitBox.visible = false;

      updateDrainVisual();
      updateFlowFromDrain();

      drainHub.addEventListener('pointerDown', onDrainDown);
      drainBar1.addEventListener('pointerDown', onDrainDown);
      drainBar2.addEventListener('pointerDown', onDrainDown);
      drainHitBox.addEventListener('pointerDown', onDrainDown);
    }

    function updateDrainVisual() {
      const wheelSpin = dtheta * 4;
      drainHub.spinT  = wheelSpin;
      drainBar1.spinT = wheelSpin;
      drainBar2.spinT = wheelSpin;
      drainHitBox.spinT = wheelSpin;
    }

    function updateFlowFromDrain() {
      const x = (dtheta - DTHETA_MIN) / (DTHETA_MAX - DTHETA_MIN);
      Qout = QoutMax * x * x;
    }

    function rebuildDrainPosition() {
      const dx = -L/2 - 4;
      const dy = wallT + 1;
      const dz = 0;

      drainBody.center = [dx, dy, dz];
      drainSpout.center = [dx + 7, dy, dz];
      if (drainStream) drainStream.center = [dx - 7, dy - 16, dz];

      const vx = dx;
      const vy = dy + 7.5;
      const vz = dz;

      drainHub.center = [vx, vy, vz];
      drainBar1.center = [vx, vy, vz];
      drainBar2.center = [vx, vy, vz];
      drainHitBox.center = [vx, vy, vz];
    }

    // ---------------------------
    // Orbit
    // ---------------------------
    function configureOrbit() {
      O.enablePan = false;

      if (window.THREE && THREE.MOUSE && O.mouseButtons) {
        O.mouseButtons.LEFT  = THREE.MOUSE.PAN;
        O.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;
      }
    }

    // ---------------------------
    // Drag
    // ---------------------------
    function onValveDown(event) {
      event.preventDefault?.();
      event.stopImmediatePropagation?.();
      event.stopPropagation?.();

      draggingValve = true;
      activePointerId = (event.pointerId !== undefined) ? event.pointerId : null;

      dragStartClientX = event.clientX;
      thetaAtDragStart = theta;

      window.addEventListener('pointermove', onPointerMoveValve, { passive: false });
      window.addEventListener('pointerup', onPointerUpValve, { passive: false, once: true });
      window.addEventListener('pointercancel', onPointerUpValve, { passive: false, once: true });
    }

    function onPointerMoveValve(event) {
      if (!draggingValve) return;
      if (activePointerId !== null && event.pointerId !== activePointerId) return;

      event.preventDefault?.();

      const dx = event.clientX - dragStartClientX;
      theta = clamp(thetaAtDragStart + dx * 0.25, THETA_MIN, THETA_MAX);

      updateValveVisual();
      updateFlowFromValve();
      updateStats();
    }

    function onPointerUpValve(event) {
      if (activePointerId !== null && event.pointerId !== activePointerId) return;

      draggingValve = false;
      activePointerId = null;

      window.removeEventListener('pointermove', onPointerMoveValve);
    }

    function onDrainDown(event) {
      event.preventDefault?.();
      event.stopImmediatePropagation?.();
      event.stopPropagation?.();

      draggingDrain = true;
      dActivePointerId = (event.pointerId !== undefined) ? event.pointerId : null;

      dDragStartClientX = event.clientX;
      dthetaAtDragStart = dtheta;

      window.addEventListener('pointermove', onPointerMoveDrain, { passive: false });
      window.addEventListener('pointerup', onPointerUpDrain, { passive: false, once: true });
      window.addEventListener('pointercancel', onPointerUpDrain, { passive: false, once: true });
    }

    function onPointerMoveDrain(event) {
      if (!draggingDrain) return;
      if (dActivePointerId !== null && event.pointerId !== dActivePointerId) return;

      event.preventDefault?.();

      const dx = event.clientX - dDragStartClientX;
      dtheta = clamp(dthetaAtDragStart + dx * 0.25, DTHETA_MIN, DTHETA_MAX);

      updateDrainVisual();
      updateFlowFromDrain();
      updateStats();
    }

    function onPointerUpDrain(event) {
      if (dActivePointerId !== null && event.pointerId !== dActivePointerId) return;

      draggingDrain = false;
      dActivePointerId = null;

      window.removeEventListener('pointermove', onPointerMoveDrain);
    }

    function onHandleDown(axis, event) {
      event.preventDefault?.();
      event.stopImmediatePropagation?.();
      event.stopPropagation?.();

      draggingHandle = axis;
      handleStartX = event.clientX;
      handleStartY = event.clientY;

      startL = L;
      startW = W;
      startH = H;

      window.addEventListener('pointermove', onHandleMove, { passive: false });
      window.addEventListener('pointerup', onHandleUp, { passive: false, once: true });
      window.addEventListener('pointercancel', onHandleUp, { passive: false, once: true });
    }

    function onHandleMove(event) {
      if (!draggingHandle) return;
      event.preventDefault?.();

      const dx = event.clientX - handleStartX;
      const dy = handleStartY - event.clientY;

      if (draggingHandle === 'x') L = Math.max(10, startL + dx * 0.15);
      if (draggingHandle === 'z') W = Math.max(10, startW + dx * 0.15);
      if (draggingHandle === 'y') H = Math.max(5,  startH + dy * 0.15);

      buildPool();
      updateWaterFromVolume();

      buildHandles();
      rebuildFaucetPosition();
      rebuildDrainPosition();

      const A = (L - 2*wallT) * (W - 2*wallT);
      const Vmax = A * (H - wallT);
      V = clamp(V, 0, Vmax);
      updateWaterFromVolume();
      updateStats(true);
    }

    function onHandleUp(event) {
      draggingHandle = null;
      window.removeEventListener('pointermove', onHandleMove);
    }

    // ---------------------------
    //(onTime)
    // ---------------------------
    function tick() {
      if (!sceneReady) return;

      if (!running) { updateStats(); return; }

      const nowMs = performance.now();
      let dt = (nowMs - lastMs) / 1000;
      lastMs = nowMs;

      dt = clamp(dt, 0, 0.1);

      const A = (L - 2*wallT) * (W - 2*wallT);
      const Vmax = A * (H - wallT);

      const canDrain = (V > 0.0001);
      const effectiveQout = canDrain ? Qout : 0;

      V += (Q - effectiveQout) * dt;
      V = clamp(V, 0, Vmax);

      if (drainStream) drainStream.visible = (effectiveQout > 0.5);

      updateWaterFromVolume();

      if (drainStream && drainStream.visible) {
        const open = (dtheta - DTHETA_MIN) / (DTHETA_MAX - DTHETA_MIN);
        const pulse = 1 + 0.12 * Math.sin((nowMs / 1000) * 18);
        const r = 0.6 + 1.0 * open;
        drainStream.size = [r * pulse, 16, r];
      }

      if (stream && stream.visible) {
        const timeS = nowMs / 1000;

        const open = (theta - THETA_MIN) / (THETA_MAX - THETA_MIN);
        const pulse = 1 + 0.12 * Math.sin(timeS * 18);
        const r = 0.6 + 1.0 * open;

        let waterSurfaceY = (V > 0.0001) ? (waterObj.center[1] + waterObj.size[1] / 2) : wallT;
        waterSurfaceY = Math.min(waterSurfaceY, streamTopY - 0.2);

        let len = streamTopY - waterSurfaceY;
        len = clamp(len, 0.2, 200);

        stream.size = [r * pulse, len, r];
        stream.center = [streamX, waterSurfaceY, streamZ];
      }

      updateStats();
    }

    // ---------------------------
    // Start
    // ---------------------------
    window.addEventListener('DOMContentLoaded', () => {
      connectUI();

      buildPool();
      updateWaterFromVolume();
      buildFaucet();
      buildDrain();
      buildHandles();
      configureOrbit();

      sceneReady = true;
      updateStats(true);
    });
</script>

</body>
</html>
