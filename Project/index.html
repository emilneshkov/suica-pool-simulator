<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Suica Pool Simulator</title>

  <script src="suica.js"></script>
  <style>
    body { margin: 0; }
  </style>
</head>

<body>
  <suica fullWindow id="S" ontime="tick">
    <orbit id="O"></orbit>
  </suica>

  <script>
    // ---------------------------
    // 1) Pool Params
    // ---------------------------
    let L = 60;
    let W = 35;
    let H = 25;
    const wallT = 1.2;

    // ---------------------------
    // 2) Filling Params
    // ---------------------------
    let V = 0;
    let running = true;

    let theta = 0;
    const THETA_MIN = 0;
    const THETA_MAX = 90;

    const Qmax = 20000;
    let Q = 0;

    // Drag state
    let draggingValve = false;
    let dragStartClientX = 0;
    let thetaAtDragStart = 0;
    let activePointerId = null;

    // --- Resize handles ---
    let handleX, handleZ, handleY;
    let draggingHandle = null;
    let handleStartX = 0;
    let handleStartY = 0;
    let startL = 0, startW = 0, startH = 0;

    // Objs
    let faucetBody, faucetNeck, faucetSpout, stream;
    let valveBar1, valveBar2, valveHub, valveHitBox;

    let floorObj, wallX1, wallX2, wallZ1, wallZ2, waterObj;

    let lastMs = performance.now();

    function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }

    function buildPool() {
      if (floorObj) {
        floorObj.visible = false;
        wallX1.visible = false; wallX2.visible = false;
        wallZ1.visible = false; wallZ2.visible = false;
        waterObj.visible = false;
      }

      floorObj = S.cube([0, wallT/2, 0], [L, wallT, W], 'gainsboro');

      wallZ1 = S.cube([0, H/2,  (W/2 - wallT/2)], [L, H, wallT], 'lightgray');
      wallZ2 = S.cube([0, H/2, -(W/2 - wallT/2)], [L, H, wallT], 'lightgray');

      wallX1 = S.cube([ (L/2 - wallT/2), H/2, 0], [wallT, H, W], 'lightgray');
      wallX2 = S.cube([-(L/2 - wallT/2), H/2, 0], [wallT, H, W], 'lightgray');

      waterObj = S.cube([0, wallT + 0.05, 0], [L - 2*wallT, 0.1, W - 2*wallT], 'deepskyblue');
    }

    function updateWaterFromVolume() {
      const A = (L - 2*wallT) * (W - 2*wallT);
      const Vmax = A * (H - wallT);

      if (!Number.isFinite(V)) V = 0;
      V = clamp(V, 0, Vmax);

      const h = V / A;
      const waterH = Math.max(0.1, h);

      waterObj.size = [L - 2*wallT, waterH, W - 2*wallT];
      waterObj.center = [0, wallT + waterH/2, 0];
    }

    function buildHandles() {
      if (handleX) {
        handleX.visible = false;
        handleY.visible = false;
        handleZ.visible = false;
      }

      handleX = S.cube([L/2 + 3, H/2, 0], [2, 2, 2], 'red');
      handleZ = S.cube([0, H/2, W/2 + 3], [2, 2, 2], 'blue');
      handleY = S.cube([0, H + 3, 0], [2, 2, 2], 'green');

      handleX.alpha = handleY.alpha = handleZ.alpha = 0.8;

      handleX.addEventListener('pointerDown', e => onHandleDown('x', e));
      handleZ.addEventListener('pointerDown', e => onHandleDown('z', e));
      handleY.addEventListener('pointerDown', e => onHandleDown('y', e));
    }

    // ---------------------------
    //Faucet
    // ---------------------------
    function buildFaucet() {
      const fx = L/2 + 12;
      const fy = H + 6;
      const fz = 0;

      const bodyCenterY = fy - 30;
      const bodyH = 45;

      faucetBody = S.cylinder([fx, bodyCenterY, fz], [6, bodyH, 6], 'silver');

      faucetNeck = S.cylinder([fx, fy+6, fz], [5, 12, 5], 'silver');
      faucetNeck.spinS = 90;

      faucetSpout = S.cylinder([fx-8, fy+6, fz], [3.2, 10, 3.2], 'silver');
      faucetSpout.spinS = 90;

      stream = S.cylinder([fx-18, fy-23, fz], [1.2, 30, 1.2], 'deepskyblue');
      stream.visible = false;

      const topOfBodyY = bodyCenterY + bodyH;
      const vx = fx;
      const vy = topOfBodyY + 0.7;
      const vz = fz;

      valveHub  = S.cylinder([vx, vy, vz], [3.2, 2.2, 3.2], 'dimgray');
      valveBar1 = S.cube([vx, vy, vz], [12, 1.4, 2.2], 'dimgray');
      valveBar2 = S.cube([vx, vy, vz], [2.2, 1.4, 12], 'dimgray');

      valveHitBox = S.cube([vx, vy, vz], [16, 8, 16], 'white');
      valveHitBox.visible = false;

      updateValveVisual();
      updateFlowFromValve();

      valveHub.addEventListener('pointerDown', onValveDown);
      valveBar1.addEventListener('pointerDown', onValveDown);
      valveBar2.addEventListener('pointerDown', onValveDown);
      valveHitBox.addEventListener('pointerDown', onValveDown);
    }

    function updateValveVisual() {
      const wheelSpin = theta * 4;
      valveHub.spinT  = wheelSpin;
      valveBar1.spinT = wheelSpin;
      valveBar2.spinT = wheelSpin;
      valveHitBox.spinT = wheelSpin;
    }

    function updateFlowFromValve() {
      const x = (theta - THETA_MIN) / (THETA_MAX - THETA_MIN);
      Q = Qmax * x * x;
      stream.visible = (Q > 0.5);
    }

    function rebuildFaucetPosition() {
      const fx = L/2 + 12;
      const fy = H + 6;

      const bodyCenterY = fy - 30;
      const bodyH = 45;

      faucetBody.center = [fx, bodyCenterY, 0];
      faucetBody.size = [6, bodyH, 6];

      faucetNeck.center = [fx, fy+6, 0];
      faucetSpout.center = [fx-8, fy+6, 0];

      stream.center = [fx-18, fy-23, 0];

      const topOfBodyY = bodyCenterY + bodyH;
      const vy = topOfBodyY + 0.7;

      valveHub.center = [fx, vy, 0];
      valveBar1.center = [fx, vy, 0];
      valveBar2.center = [fx, vy, 0];
      valveHitBox.center = [fx, vy, 0];
    }

    function configureOrbit() {
      O.enablePan = false;

      if (window.THREE && THREE.MOUSE && O.mouseButtons) {
        O.mouseButtons.LEFT  = THREE.MOUSE.PAN;
        O.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;
      }
    }

    function onValveDown(event) {
      event.preventDefault?.();
      event.stopImmediatePropagation?.();
      event.stopPropagation?.();

      draggingValve = true;
      activePointerId = (event.pointerId !== undefined) ? event.pointerId : null;

      dragStartClientX = event.clientX;
      thetaAtDragStart = theta;

      window.addEventListener('pointermove', onPointerMoveValve, { passive: false });
      window.addEventListener('pointerup', onPointerUpValve, { passive: false, once: true });
      window.addEventListener('pointercancel', onPointerUpValve, { passive: false, once: true });
    }

    function onPointerMoveValve(event) {
      if (!draggingValve) return;
      if (activePointerId !== null && event.pointerId !== activePointerId) return;

      event.preventDefault?.();

      const dx = event.clientX - dragStartClientX;
      theta = clamp(thetaAtDragStart + dx * 0.25, THETA_MIN, THETA_MAX);

      updateValveVisual();
      updateFlowFromValve();
    }

    function onPointerUpValve(event) {
      if (activePointerId !== null && event.pointerId !== activePointerId) return;

      draggingValve = false;
      activePointerId = null;

      window.removeEventListener('pointermove', onPointerMoveValve);
    }

    function onHandleDown(axis, event) {
      event.preventDefault?.();
      event.stopImmediatePropagation?.();
      event.stopPropagation?.();

      draggingHandle = axis;
      handleStartX = event.clientX;
      handleStartY = event.clientY;

      startL = L;
      startW = W;
      startH = H;

      window.addEventListener('pointermove', onHandleMove, { passive: false });
      window.addEventListener('pointerup', onHandleUp, { passive: false, once: true });
      window.addEventListener('pointercancel', onHandleUp, { passive: false, once: true });
    }

    function onHandleMove(event) {
      if (!draggingHandle) return;
      event.preventDefault?.();

      const dx = event.clientX - handleStartX;
      const dy = handleStartY - event.clientY;

      if (draggingHandle === 'x') L = Math.max(10, startL + dx * 0.15);
      if (draggingHandle === 'z') W = Math.max(10, startW + dx * 0.15);
      if (draggingHandle === 'y') H = Math.max(5,  startH + dy * 0.15);

      buildPool();
      updateWaterFromVolume();

      buildHandles();
      rebuildFaucetPosition();

      const A = (L - 2*wallT) * (W - 2*wallT);
      const Vmax = A * (H - wallT);
      V = clamp(V, 0, Vmax);
      updateWaterFromVolume();
    }

    function onHandleUp(event) {
      draggingHandle = null;
      window.removeEventListener('pointermove', onHandleMove);
    }

    function tick() {
      if (!running) return;

      const nowMs = performance.now();
      let dt = (nowMs - lastMs) / 1000;
      lastMs = nowMs;

      dt = clamp(dt, 0, 0.1);

      V += Q * dt;
      updateWaterFromVolume();
    }

    // ---------------------------
    // Start
    // ---------------------------
    buildPool();
    updateWaterFromVolume();
    buildFaucet();
    buildHandles();
    configureOrbit();
  </script>
</body>
</html>
